---
title: A Heat Diffusion-based Ricci Curvature and Applications to GNNs
author:
  - name: Kincaid MacDonald
    orcid: 0000-0002-0760-5497
    corresponding: true
    email: kincaid@aya.yale.edu
    roles: []
    affiliations:
    - Yale
  - name: Dhananjay Bhaskar
    orcid: 0000-0002-7859-8394
    corresponding: false
    roles: []
    affiliations: 
    - MILA
  - name: Kaly Zhang
    orcid: 0000-0002-7859-8394
    corresponding: false
    roles: []
    affiliations: 
    - MILA
  - name: Xingzhi Sun
    orcid: 0000-0002-7859-8394
    corresponding: false
    roles: []
    affiliations: 
    - Yale
  - name: Ian Adelstein
    orcid: 0000-0002-7859-8394
    corresponding: false
    roles: []
    affiliations:
    - Yale Department of Math
  - name: Smita Krishnaswamy
    orcid: 0000-0002-7859-8394
    corresponding: false
    roles: []
    affiliations:
    - Yale Department of Applied Math
    - Yale School of Medicine
keywords:
    - Manifold Learning
    - Geometric Deep Learning
    - Graph Curvature
    - Point Clouds
abstract: 
    For a number of years now work has been proceeding in order to bring to perfection the crudely conceived idea of a machine that would not only supply inverse reactive current for use in unilateral phase detractors, but would also be capable of automatically synchronizing cardinal grammeters. Such a machine is the "Turbo-Encabulator."
plain-language-summary: |
    We introduce Diffusion Curvature, a fast, differentiable, noise-robust pointwise curvature for graphs and point clouds.
key-points: []
date: last-modified
bibliography: references.bib
citation:
    container-title: IEEE TPAMI
number-sections: true
---

## Introduction

Recent years have seen a growing appreciation that black-box machine learning methods can understand data better if equipped with geometric priors, both globally [cite TDA methods] and locally [cite heat & wave, energy]. This is especially true for graph-structured data. The graph manages to be the most general data structure only by ripping itself from the extrinsic context in which geometric measures like curvature are most easily derived. While pointclouds within ambient space can be viewed *extrinsically*, like an astronaut’s view of the Earth, the graph’s view of itself is solely *intrinsic*, like Poincare’s ant on a sphere.

Though there exist purely intrinsic measures of geometry, they are (as intuition would suggest) more specialized and arcane then extrinsic measures, involving complex constructs like optimal transport and geodesics. The result: while point cloud-based neural networks (feedforward, CNNs, diffusion models) can easily by themselves infer geometry through their extrinsic view, GNNs are left with a much harder problem: deriving the complex machinery of, e.g., geodesics and Wasserstein distances from scratch.

Here we present an alternative: a differentiable, scale-invariant, noise-resistant module that equips GNNs with graph curvatures.
<!-- 

Recent years have seen a growing appreciation that black-box machine learning methods can understand data better if equipped with geometric priors, both globally [cite TDA methods] and locally [cite heat & wave, energy]. This is especially true for graph-structured data. The usefulness of graphs as a general data representation comes at a cost: that data is “ripped from its context”. To take an example, when point cloud data becomes a graph, the *extrinsic* geometric perspective afforded by a bird’s eye view of the points is reduced to an *intrinsic* perspective – the ‘ant’s eye’ view. 

Outline:
-  -->


# Diffusion Ricci Curvature




{{< embed ../nbs/experiments/2c3-are-kernels-zeitgeibers.ipynb#fig-spread-of-diffusion-2d >}}

## Data & Methods {#sec-data-methods}

```{python}
#| label: torus
#| fig-cap: Diffusion Curvature vs Gaussian Curvature of the Torus
#| fig-alt: The diffusion curvature corresponds closely to the gaussian curvature of the torus
from diffusion_curvature.utils import plot_3d
from diffusion_curvature.datasets import torus
from diffusion_curvature.core import DiffusionCurvature, get_adaptive_graph
X_torus, ks_torus = torus(2000)
DC = DiffusionCurvature()
G_torus = get_adaptive_graph(X_torus, k = 5, alpha = 1)
ks_computed = DC.curvature(G_torus, dim=2, t = 25)
plot_3d(X_torus, ks_computed, colorbar=True)
```

## Conclusion

## References {.unnumbered}

::: {#refs}
:::